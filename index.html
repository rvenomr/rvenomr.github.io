<html>
<style>
      body {
         height : 100%;
         width : 100%;
      }
      canvas { 
         height: 100%;
         width: 100%;
      }
   </style>
  <body>
    <canvas id = "canvas" width="1400" height="800"></canvas>
    <script>
const degToRad = (degrees) => {
  return degrees / 180 * Math.PI;
}

const randomRange = (min, max) => {
  return Math.random() * (max - min) + min;
}

function getTouchPos(canvasDom, touchEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: touchEvent.touches[0].clientX - rect.left,
    y: touchEvent.touches[0].clientY - rect.top
  };
}

let text = "TOUCH ME"
let fontSize = 20;
let fontFamily = 'serif';
let flag = [];

let cursX;
let cursY;
var canvas = document.getElementById("canvas");
var width = canvas.width;
var height = canvas.height;
var context = canvas.getContext("2d");

canvas.addEventListener("touchstart", function (e) {
        mousePos = getTouchPos(canvas, e);
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousedown", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  cursX = touch.clientX;
  cursY = touch.clientY;
  canvas.dispatchEvent(mouseEvent);
  
}, false);
canvas.addEventListener("touchend", function (e) {
  var mouseEvent = new MouseEvent("mouseup", {});
  canvas.dispatchEvent(mouseEvent);
}, false);

canvas.addEventListener("touchmove", function (e) {
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousemove", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  cursX = touch.clientX;
  cursY = touch.clientY;
  canvas.dispatchEvent(mouseEvent);
  draw();
}, false);

document.addEventListener("mousemove", function(e) {
  context.clearRect(0, 0, canvas.width, canvas.height);
  cursX = e.pageX,
  cursY =  e.pageY
  draw();
})

window.addEventListener("unload", function(){
  flag = [];
}, false);

const getDistance =(x1, y1, x2, y2) => {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
}

const onMouseMove = (e) => {
  cursX = e.pageX;
  cursY = e.pageY;
  manager.render();
}

document.addEventListener("mousemove", onMouseMove)
const typeCanvas = document.createElement('canvas');
const typeContext = typeCanvas.getContext('2d') //{willReadFrequently: true});

function draw(){
  const cell = 10;
  const gridw = width  * 0.8;
  const gridh = height * 0.8
  const cols = Math.floor(gridw / cell);

  const rows = Math.floor(gridh / cell);
  const numCells = cols * rows;

  typeCanvas.width = cols;
  typeCanvas.height = rows;

  const margx = (width - gridw) * 0.5;
  console.log(margx);
  const margy = (height - gridh) * 0.5;

  typeContext.fillStyle = 'white';
  typeContext.fillRect(0, 0, cols, rows);

    fontSize = fontSize;

    typeContext.fillStyle = 'black';
    typeContext.font = `${fontSize}px ${fontFamily}`;
    typeContext.textBaseline = 'top';

    const metrics = typeContext.measureText(text);
    const mx = metrics.actualBoundingBoxLeft * -1;
    const my = metrics.actualBoundingBoxAscent * -1;
    const mw = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
    const mh = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
    
    const tx = mx * 2;
    const ty = my;

    typeContext.save();
    typeContext.translate(tx, ty);

    typeContext.beginPath();
    typeContext.stroke();

    typeContext.fillText(text, 0, 0);
    typeContext.restore();

    const typeData = typeContext.getImageData(0, 0, cols, rows).data;
    context.fillStyle = 'black';
    context.drawImage(typeCanvas, 0, 0);
    context.fillRect(0, 0, width, height);
    context.textBaseline = 'middle';
    context.textAlign = 'center';

    for (let i = 0; i <= typeData.length/4; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);

      const x = col * cell + margx + cell * 0.5;
      const y = row * cell + height*0.3;

      let angle = Math.atan2(y - cursY, x - cursX);
      
        const r = typeData[i * 4 + 0];
        const g = typeData[i * 4 + 1];
        const b = typeData[i * 4 + 2];
        const a = typeData[i * 4 + 3];

        context.fillStyle = `rgb(${r}, ${g}, ${b})`;
        
        if(r < 147){
          flag[i] = true;
          /*
          console.log("r " + r);
          console.log("g " + g);
          console.log("b " + b);
          console.log("a " + a);
          */
        } else {
          flag[i] = false;
          }
      if(flag[i]){
        context.save();
        context.translate(x, y);
        context.rotate(angle);
        context.scale(3, 3);
        context.beginPath();
        let c = randomRange(1, 3.5);
        
        color = ''
        if(getDistance(x, y, cursX, cursY) > 150){
          color = 'rgb(82, 78, 238)';
      
        } else {
          //context.fillStyle = 'rgb(159, 179, 238)';
          let c =randomRange(1,2)
          if(c > 1.5){
            color =  'rgb(203, 0, 104)';
          } else {
            color = 'rgb(244, 232, 0)';
          }
        }
        context.fillStyle = color;
        context.beginPath();

        //context.lineCap = params.lineCap;

        //context.moveTo(cell * -0.5, 0);
        //context.lineTo(cell *  0.5, 0);
        context.rect(-cell * 0.5, -cell * 0.5, cell * 0.15, cell * 1.1);
        //context.arc(0, 0, random.range(4, 12), 0, Math.PI * 2);
        context.fill();
        //context.stroke();
        context.restore();
        context.restore();
    }
  }
}
    </script>
  </body>
</html>